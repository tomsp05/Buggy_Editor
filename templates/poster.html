{% extends "base.html" %}
{% block content %}

<style>
body {
  font-family: Arial, sans-serif;
  line-height: 1.6;
  margin: 0;
  padding: 0;
  background-color: #f8f9fa;
}

h1 {
  text-align: center;
  margin-top: 1em;
  color: #333;
  font-size: 2.5em;
}

.phase {
  text-align: left;
  max-width: 1200px;
  margin: 2em auto;
  background: white;
  padding: 2em;
  border-radius: 10px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

.section {
  text-align: center;
  max-width: 1400px;
  margin: 2em auto;
  background: rgb(238, 238, 238);
  color: #626262;
  padding: 2em;
  border-radius: 10px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

.phase h2 {
  text-align: center;
  margin-bottom: 1em;
}

.poster-tasks {
  display: grid;
  grid-template-columns: 1fr;
  gap: 1.5em;
  justify-content: center;
}

.task {
  padding: 1.5em;
  border: 1px solid #ccc;
  border-radius: 8px;
  background-color: #fff;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}

.task h2 {
  border-bottom: 3px solid #007bff;
  padding-bottom: 0.5em;
  margin-bottom: 1em;
  color: #007bff;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.task p {
  margin: 0.5em 0;
}

.task .content {
  display: none;
  overflow: hidden;
  transition: max-height 0.2s ease-out;
}

.task .preview {
  display: block;
  max-height: 4.5em;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.footer {
  text-align: center;
  padding: 1em;
  margin-top: 2em;
  font-size: 0.9em;
  color: #777;
}

.home-button a {
        display: inline-block;
        padding: 10px 20px;
        border-radius: 5px;
        background-color: #007BFF;
        color: white;
        text-decoration: none;
        font-size: 16px;
    }

.arrow {
  font-size: 1.2em;
  transition: transform 0.2s ease-out;
}
</style>

<script>
function toggleContent(event) {
  const task = event.currentTarget.closest('.task');
  const content = task.querySelector('.content');
  const arrow = task.querySelector('.arrow');
  const preview = task.querySelector('.preview');

  if (content.style.display === "block") {
    content.style.display = "none";
    preview.style.display = "block";
    arrow.style.transform = "rotate(0deg)";
  } else {
    content.style.display = "block";
    preview.style.display = "none";
    arrow.style.transform = "rotate(90deg)";
  }
}
</script>

<h1>Poster</h1>

<div class="section">
  <h2>Features of my editor:</h2>
  <img src="{{ url_for('static', filename='editor-SS.png') }}" alt="Editor Screenshot" width="1075" height="1434" style="border-radius: 10px;">
</div>



<div class="section">
  <h2>Task Explanations: </h2>

  <div class="phase">
  <h2>Phase 0</h2>
  <section class="poster-tasks">
    
    <div class="task">
      <h2 onclick="toggleContent(event)">0-GET Get the source code <span class="arrow">▶</span></h2>
      <div class="preview">
        First I downloaded the latest version of Python3 from the python installer. Then, to check that it was...
      </div>
      <div class="content">
        <p>
          First I downloaded the latest version of Python3 from the python installer. Then, to check that it was installed correctly on my device I checked the current python version in terminal using the "python --version" command. Then, because I already had Visual Studio code installed, I opened Visual Studio and tested that python files worked. Once python was correctly installed and tested I downloaded the .zip file for the source code and unzipped the downloaded file. Opened this folder up in Visual Studio and completed the task.
        </p>
        <p>
          <!-- sentence(s) on anything interesting/incomplete you did -->
        </p>
      </div>
    </div>

    <div class="task">
      <h2 onclick="toggleContent(event)">0-RUN Get app running and view it in a browser <span class="arrow">▶</span></h2>
      <div class="preview">
        First I Installed the library dependencies by running 'pip3 install -r requirements.txt' in the Visual Studio...
      </div>
      <div class="content">
        <p>
          First I Installed the library dependencies by running 'pip3 install -r requirements.txt' in the Visual Studio terminal. Then I setup the SQL database for the buggy editor app by running 'python3 init_db.py'. It was recommended to run in Flask's development environment so any changes made to the code would immediately be reflected on the web browser. In the terminal I ran 'export FLASK_ENV=development' to initialise the development environment. Then I ran the Buggy Editor using 'python3 app.py' in the Visual Studio terminal. The buggy editor was meant to run as a webserver on port 5000 but an error was given stating that the port was already in use on my device. To fix this, rather than stop the operation currently using port 5000 I changed the app.py to run on port 5100. After I did this I opened up http://127.0.0.1:5100/ and the Buggy Editor was displayed.
        </p>
        <p>
          <!-- sentence(s) on anything interesting/incomplete you did -->
        </p>
      </div>
    </div>

    <div class="task">
      <h2 onclick="toggleContent(event)">0-CHANGE Make a change to a template and see it appear <span class="arrow">▶</span></h2>
      <div class="preview">
        To test changing the website I navigated to the 'index.html' file within the 'templates' file. Simply changed...
      </div>
      <div class="content">
        <p>
          To test changing the website I navigated to the 'index.html' file within the 'templates' file. Simply changed the header from "My buggy editor" to "Buggy Editor". This change was updated on the webserver in the browser.
        </p>
        <p>
          <!-- sentence(s) on anything interesting/incomplete you did -->
        </p>
      </div>
    </div>
  </section>
  </div>

  <div class="phase">
  <h2>Phase 1</h2>
  <section class="poster-tasks">

    <div class="task">
      <h2 onclick="toggleContent(event)">1-TEMPLATE Add a new template and route to the app <span class="arrow">▶</span></h2>
      <div class="preview">
        First i created a new template in the templates folder by duplicating an existing template. Then I created...
      </div>
      <div class="content">
        <p>
          First i created a new template in the templates folder by duplicating an existing template. Then I created a new route for the info page. Once this was done I ran the webserver and tested the url 'http://127.0.0.1:5100/info' which displayed the new template that I had created.
        </p>
        <p>
          <!-- sentence(s) on anything interesting/incomplete you did -->
        </p>
      </div>
    </div>

    <div class="task">
      <h2 onclick="toggleContent(event)">1-ADD Add more data to the form and save it to the database <span class="arrow">▶</span></h2>
      <div class="preview">
        Within the 'buggy-form.html' template I added a new label and input tags for the flag_color input section...
      </div>
      <div class="content">
        <p>
          Within the 'buggy-form.html' template I added a new label and input tags for the flag_color input section for the form. While testing the form i thought it would be useful to include default values, to do this I updated the input line for both the number of wheels and the flag colour to include a value.
          To allow the user to easily pick a colour I set the input type to 'color' which provides the user with a colour picker on the form. This is the line used for implementing the flag colour into the form: input type="color" id="flag_color" name="flag_color" value="#ff0000" required
          
          To update the database correctly with both the number of wheels and the flag colour I updated the post method in the /new route within the app.py file. I added in the flag_color variable and set it to the inputted value from the form, then updated the buggies database accordingly by using this SQL command: UPDATE buggies set qty_wheels=?,flag_color=? WHERE id=?
          
          Then, I wanted to include the options from the JSON file in the form to allow users to select their preferred configurations for the buggy. This is done by loading the options from the JSON file on the server side and passing them to the HTML template. The benefits of using a .JSON file rather than hardcoding the options into the. In the form, i created dropdown menus for each category of options, such as armour and power type. Each dropdown menu contains with the choices from the JSON file, letting users to easily select the options they want. When the user submits the form, the selected options are saved and sent to the server. The server then processes these selections, making they are included in the database update. Alongside the other details like the number of wheels and flag colour, the selected options are stored in the database by using the same method as outlined before.      </p>
        <p>
          <!-- sentence(s) on anything interesting/incomplete you did -->
        </p>
      </div>
    </div>

    <div class="task">
      <h2 onclick="toggleContent(event)">1-VALID Add basic data validation <span class="arrow">▶</span></h2>
      <div class="preview">
        First I updated the python code within the app.py file to add validation to 'qty_wheels'. First I converted...
      </div>
      <div class="content">
        <p>
          First I updated the python code within the app.py file to add validation to 'qty_wheels'. First I converted the input 'qty_wheels' to an integer, added in some logic that checked whether 'qty_wheels' is a valid integer or not. If it is either not a valid integer or is less than/equal to zero then a 'ValueError' is raised. If the validation fails and the input is determined to not be valid, an error message is set and the form shows an error message to inform the user. try: qty_wheels = int(qty_wheels) if qty_wheels <= 0: raise ValueError("Number of wheels must be a positive integer") except ValueError: msg = "Invalid input: Number of wheels must be a positive integer" return render_template("buggy-form.html", msg=msg) To update the form on the website to show the user that their input wasn't valid, I updated 'buggy-form.html' to include a mesage box that includes the error. {% if msg %}
          {{ msg }}
          
          {% endif %} Then, as extra validation, I added in error handling to the database operations. This is to catch any exception that happens during the database operations, the transaction is reversed and an error message is set that details the exception. except Exception as e: con.rollback() msg = f"Error in update operation: {str(e)}"      </p>
        <p>
          <!-- sentence(s) on anything interesting/incomplete you did -->
        </p>
      </div>
    </div>

    <div class="task">
      <h2 onclick="toggleContent(event)">1-STYLE Style your editor <span class="arrow">▶</span></h2>
      <div class="preview">
        I made a few changes to the styling of the webpage to improve its visual appeal and functionality for the user...
      </div>
      <div class="content">
        <p>
          I made a few changes to the styling of the webpage to improve its visual appeal and functionality for the user. Firstly, I added a `.form-container` class to center the form on the page, applying padding, a border and a background colour. The `h1` header is now centre-aligned with a new colour. Labels have been styled to be bold with added spacing for better readability. Input elements have been widened, given padding, and rounded corners. The `input[type="submit"]` button has been given a background colour, white text, and a hover effect for interactivity. Additionally, I included a `color-preview` div to display the selected colour and styled the `home-button` link to look like a button.

          I added an event listener to the colour input (using javascript) to dynamically update the colour preview. The initial colour of the preview now matches the default value of the colour input when the page loads.

          I wrapped the form in a `div` with the class `.form-container`. I also included a `div` with the class `.color-preview` to show the flag colour and styled the error message with a red colour and centre alignment to make sure it is noticeable.

          Finally, rather than just updating the styling of the buggy editor page i decided to follow these style choices through to the index page (serves as the homepage for the webpage). To do this i used similar CSS on the index.html template.
        </p>
        <p>
          <!-- sentence(s) on anything interesting/incomplete you did -->
        </p>
      </div>
    </div>
  </section>
  </div>

  <div class="phase">
  <h2>Phase 2</h2>
  <section class="poster-tasks">

    <div class="task">
      <h2 onclick="toggleContent(event)">2-EDIT Allow for editing of a buggy by preloading its current values into the form <span class="arrow">▶</span></h2>
      <div class="preview">
        First, I updated the edit_buggy function in the app.py file to get the current settings of the buggy from the...
      </div>
      <div class="content">
        <p>
          First, I updated the edit_buggy function in the app.py file to get the current settings of the buggy from the database using an SQL SELECT query. The function gets the values stored in the database for the current buggy (as there is only one buggy in the database it gets the values in the only row, then passes these values to the buggy-form.html template. If no record is found the default values are used. In the buggy-form.html template, then I updated the form fields to use the passed values, making sure the form is pre-filled with the current settings by using logic within the label and input tags, for example this is the input tag for the 'fireproof' option: input type="checkbox" id="fireproof" name="fireproof" value="true" {% if fireproof == 1 %}checked{% endif %}

          Then, to make sure the user was actually able to edit the buggy, I added a button in the index.html template to route the user to the edit.html template rather than relying on them typing the full edit url into the url bar.       </p>
        <p>
          <!-- sentence(s) on anything interesting/incomplete you did -->
        </p>
      </div>
    </div>

    <div class="task">
      <h2 onclick="toggleContent(event)">2-COST Calculate and save the game cost of the buggy <span class="arrow">▶</span></h2>
      <div class="preview">
        The total cost of the buggy is calculated dynamically while the user is creating their buggy. This is done...
      </div>
      <div class="content">
        <p>
          The total cost of the buggy is calculated dynamically while the user is creating their buggy. This is done through a JavaScript function that updates the cost whenever the user changes any options. The form includes options for armour and power type, all of which have an associated cost. The JavaScript function sums the costs of the selected armour and power type and displays the total cost in real-time on the form. When the user submits the form, the server calculates the total cost again using the same logic to ensure accuracy. This total cost is then saved to the database along with the other buggy details, making sure that the saved record accurately reflects the user's selected configuration and its cost.
        </p>
        <p>
          <!-- sentence(s) on anything interesting/incomplete you did -->
        </p>
      </div>
    </div>

    <div class="task">
      <h2 onclick="toggleContent(event)">2-RULES Add validation according to the game rules <span class="arrow">▶</span></h2>
      <div class="preview">
        To make sure the game rules are properly followed, I added validation logic to the buggy editor. The validate...
      </div>
      <div class="content">
        <p>
          To make sure the game rules are properly followed, I added validation logic to the buggy editor. The validate_buggy_data function was made to check user inputs against the game rules. This function verifies that the number of wheels is an even number and at least four, that the number of tyres is equal to or greater than the number of wheels, that the primary motive power is not set to 'none', and that the flag's primary and secondary colours are different. In addition to validation, the app.py file was updated to handle form data correctly. Boolean fields such as fireproof, insulated, antibiotic, and banging were added with proper handling to check their presence in the form submission. The SQL query was corrected to include all relevant fields, making sure that the data is saved to the database correctly. 

          The validation is completed as the user submits the buggy create/edit form via a function called validateForm(). If the inputted data doesn't comply with the game rules an alert is given to the user to explain what is wrong and what they need to do to change it. Rather than just saying that something is wrong and leaving it up to the user to figure out what, the webpage explains which part of the form needs updating.       </p>
        <p>
          <!-- sentence(s) on anything interesting/incomplete you did -->
        </p>
      </div>
    </div>
  </section>
  </div>

  <div class="phase">
  <h2>Phase 3</h2>
  <section class="poster-tasks">

    <div class="task">
      <h2 onclick="toggleContent(event)">3-ENV Switch between development and production environments <span class="arrow">▶</span></h2>
      <div class="preview">
        I first did some research to understand what the difference between different environments was and why they...
      </div>
      <div class="content">
        <p>
          I first did some research to understand what the difference between different environments was and why they were needed. After i understood the difference between a debug and production environment I used the command 'FLASK_ENV=production' in the terminal to change the working environment to a production environment from the development one. While in the production environment the changes made to the code weren't updated live on the webpage. To change back to the development environment I removed this command from the current working library command.       </p>
        <p>
          <!-- sentence(s) on anything interesting/incomplete you did -->
        </p>
      </div>
    </div>

    <div class="task">
      <h2 onclick="toggleContent(event)">3-AUTOFILL Add auto-fill to the buggy form <span class="arrow">▶</span></h2>
      <div class="preview">
        The auto-fill feature was added to the buggy editor to improve the user experience by automatically filling...
      </div>
      <div class="content">
        <p>
          The auto-fill feature was added to the buggy editor to improve the user experience by automatically filling form fields with default values. First, a new route was created in app.py to get the default values from a JSON file (defaults.json) containing the default values for the buggy. The HTML form (buggy-form.html) was then updated to include an "Auto-Fill" button, which triggers a JavaScript function to get and set these default values.

          The JavaScript function autoFill was made to handle various input types, including checkboxes, colour inputs, and dropdown menus. First attempts had issues with correctly setting colour inputs and dropdown selections. To resolve this, the function was changed to make sure colour values were formatted correctly and to take into account the case and whitespace differences in the dropdown values.       </p>
        <p>
          <!-- sentence(s) on anything interesting/incomplete you did -->
        </p>
      </div>
    </div>

    <div class="task">
      <h2 onclick="toggleContent(event)">3-MULTI Allow different buggies to be created <span class="arrow">▶</span></h2>
      <div class="preview">
        To add support for multiple buggies, a lot of changes were needed across most files in the project. The...
      </div>
      <div class="content">
        <p>
          To add support for multiple buggies, a lot of changes were needed across most files in the project. The `init_db.py` file was updated to create a new table capable of storing multiple buggies. This was done by changing the ID variable type from an int to an auto incrementing integer, this means that after each submission into the database the ID number automatically increments by one, allowing for multiple entries to be stored. In `app.py`, the home route was modified to fetch and display all buggies, and a new route (`/edit-select`) was added to display a list of buggies for selection when the user selects to edit the buggies. </p>

        <p> After these changes were added I tested the edit feature to make sure everything was working as I expected it to. I went to edit buggy number 1 in the database, the correct details were fetched from the database and were correctly used to populate the form fields. After making edits to the data I submitted the form and everything seemed to be working. Then, to check that the edits were saved I went back onto the buggy edit select page. On this page there was another buggy in the list. Rather than the edit function overwriting the entry in the database with the corresponding ID number to the buggy that the user selected It just created a new entry and kept the original one the same. This was an error that I thought I had correctly handled when modifying the edit functions. </p>
        
        <p> Now that I knew the previous method didn’t work I planned a different method of implementing multiple buggies. The buggy edit form worked by a conditional command that checked whether the user had pressed the edit buggy button or the make buggy button. The forms were the same but the http request it sent once the form was submitted was different. If the user chose to edit a POST request was sent to the server. I refined this IF statement and incorporated it into the form start tag: form id="buggy-form" action="{% if edit_mode and buggy_id %}{{ url_for('update_buggy', buggy_id=buggy_id) }}{% else %}{{ url_for('create_buggy') }}{% endif %}" method="post" onsubmit="return validateForm()”. Now everything was completed in one statement including calling the update_buggy function and the fetching of the buggy-id from the database. This changed resulted in the form correctly linking the buggy-id that the user selected to the ID sent with the POST request. I reluctantly tested the edit feature and everything worked! The correct entry in the database was updated each time the form was submitted and no duplicates were made.      </p>
        <p>
          <!-- sentence(s) on anything interesting/incomplete you did -->
        </p>
      </div>
    </div>

    <div class="task">
      <h2 onclick="toggleContent(event)">3-DEL Allow buggies to be deleted <span class="arrow">▶</span></h2>
      <div class="preview">
        Firstly, a new route was introduced in the `app.py` file to handle deleting buddies. The route, named...
      </div>
      <div class="content">
        <p>
          Firstly, a new route was introduced in the `app.py` file to handle deleting buddies. The route, named `delete_buggy`, uses the HTTP POST method to remove a given buggy from the database based on its ID. The SQL command `DELETE FROM buggies WHERE id = ?` makes sure the correct buggy is deleted. Also, the `edit-select.html` template was updated to include a delete button next to each buggy entry. This button submits a form that calls the `delete_buggy` route, confirming the user's decision to delete the buggy. 
        </p>
        <p>
          <!-- sentence(s) on anything interesting/incomplete you did -->
        </p>
      </div>
    </div>

    <div class="task">
      <h2 onclick="toggleContent(event)">3-FLAG Display the pennant graphically <span class="arrow">▶</span></h2>
      <div class="preview">
        To add the preview of the flag a canvas element was used within the "Flag Options" section to give an area...
      </div>
      <div class="content">
        <p>
          To add the preview of the flag a canvas element was used within the "Flag Options" section to give an area where the flag will be drawn. Also, I added some JavaScript functions to handle the drawing of the flag on the canvas based on the selected colours and pattern. </p>

        <p>The JavaScript code includes a drawFlag function that takes the colours inputted by the user and pattern and draws the flag on the canvas. Depending on the chosen pattern, different drawing functions are used, such as drawCheckPattern, drawDstripePattern, drawHstripePattern, drawPlainPattern, drawSpotPattern, and drawVstripePattern. These functions use the canvas's drawing area to create the patterns.</p>

        <p>I added event listeners to the form's colour and pattern inputs to call the drawFlag function whenever their values change. This makes that the flag preview is updated in real-time as the user makes their choices. The handler code also includes logic to manage the first drawing of the flag when the page loads and when the "Auto-Fill" button is used.      </p>
        <p>
          <!-- sentence(s) on anything interesting/incomplete you did -->
        </p>
      </div>
    </div>
  </section>
  </div>

  <div class="phase">
  <h2>Phase 4</h2>
  <section class="poster-tasks">

    <div class="task">
      <h2 onclick="toggleContent(event)">4-API Use the server API for submitting the buggy data <span class="arrow">▶</span></h2>
      <div class="preview">
        The process of adding the API for submitting the buggies to the race server involved many changes to how the...
      </div>
      <div class="content">
        <p>
          The process of adding the API for submitting the buggies to the race server involved many changes to how the buggy editor worked and how the user interfaces with the webpage. First, I added a new form into the current HTML structure to get the API secret code from the user to authenticate the API with the web server. The form included a hidden input field for the buggy ID, making sure that the correct buggy data would be fetched. I added JavaScript functions to show and hide the popup.
        </p>
        <p>
          I added some CSS styling to make the form match the design of the rest of the webpage. This included setting each button on the edit form to different colours to differentiate the buttons to make the process more convenient for the user.
        </p>
        <p>
          During development of this phase there were a few issues. One issue was making sure that the form closed properly after the user submitted the form, whether successful or not. This was fixed by adding a finally block in the JavaScript submitBuggyJSON function to make sure the form always closes after the API call is complete. Another issue was keeping equal spacing between all action buttons (Edit, Submit JSON, Delete). This was fixed by using CSS flexbox properties, adding a button-container class with display: flex and gap: 10px to keep consistent spacing between all three buttons.
        </p>
        <p>
          <!-- sentence(s) on anything interesting/incomplete you did -->
        </p>
      </div>
    </div>

    <div class="task">
      <h2 onclick="toggleContent(event)">4-USERS Add users (and sessions) so you know who is editing a buggy <span class="arrow">▶</span></h2>
      <div class="preview">
        I used the Flask-Login and Flask-SQLAlchemy libraries to handle user authentication and database operations...
      </div>
      <div class="content">
        <p>
          I used the Flask-Login and Flask-SQLAlchemy libraries to handle user authentication and database operations. The User table within the database was defined with columns for id, username, email, and password, so user information could be saved securely. Rather than saving passwords as plain text in the database the passwords are hashed using the werkzeug.security.generate_password_hash function with the pbkdf2:sha256 method, this is in place to prevent potential security leaks. Passwords should never be stored as plain text incase somebody unauthorised gains access to the database. Hashing is a one way process that turns the plain text into an unrecognisable string, this string can then be used to verify user details when a login is attempted.       </p>
        <p>
          I used the pbkdf2:sha256 function for the password hashing because of its strong security features and widespread use in crypto use cases. PBKDF2 (Password-Based Key Derivation Function 2) is designed to be computationally intensive, making it resistant to brute-force attacks. By using the SHA-256 hashing algorithm, it ensures that the hashed output is both strong and secure against attacks.
        </p>
        <p>
          One of the main reasons for using pbkdf2:sha256 is its ability to be able to use a salt, increasing the difficulty for attackers to crack the hashed passwords. A salt makes sure that even if two users have the same password, their hashed values will be different, preventing the use of rainbow tables to brute force the password (rainbow tables are tables that store known strings and their hashed values so attackers could potentially match known hashed values to passwords). 

        </p>
        <p>
          The /signup route handler handles user registration by taking JSON data, creating a new User entry in the table, and adding it to the database. The /login route checks user credentials against the stored hash and logs the user in using Flask-Login's login_user function if the details are correct. I also created a logout route (/logout), this route logs the user out and redirects them to them back to the login page. This was added to the homepage (index.html) by adding a logout button.

        </p>
        <p>
          At first, there was an issue with route conflicts because of duplicate function names, which was fixed by renaming one of the functions. There wan another issue from an invalid hash method being used for password hashing, which was fixed by switching to a supported method. Also, I first tried creating a brand new database for the users information but then changed my approach to use the same database as the buggy data but just create a new table within the database. 
        </p>
      </div>
    </div>

    <div class="task">
      <h2 onclick="toggleContent(event)">4-OWNER A buggy belongs to a user <span class="arrow">▶</span></h2>
      <div class="preview">
        To make sure users could only edit their buggies I first modified the database schema in `init_db.py` to add...
      </div>
      <div class="content">
        <p>
          To make sure users could only edit their buggies I first modified the database schema in `init_db.py` to add a `user_id` column to the `buggies` table, making a foreign key relationship with the `users` table. This allows the program to understand which user owns each buggy.
        </p>
        <p>
          Next, I updated the backend code in `app.py`. The routes for creating, updating, and deleting buggies were edited to include the `user_id` field and to make sure that only the owner can modify or delete their buggies. This involved adding in checks in the SQL queries to check that actions made are restricted to the buggies that belong to the user that is currently logged in. 
        </p>
        <p>
          I also changed the form in `buggy-form.html` to add in a hidden `user_id` field, making sure that this data is properly sent when creating or updating a buggy. Also, the `edit-select.html` template was modified to only show the buggies that belong to the logged-in user.

        </p>
        <p>
          One issue I came across during this process was properly checking that all the SQL queries correctly included the `user_id` check, because there was so many references throughout the code this was tedious yet important because if I missed one query any user could be able to access any buggy. 
        </p>
        <p>
          Now the users are able to login and view only their buggies, any new buggies that a user makes are tied to their username and will only be visible/editable by them. 
        </p>
      </div>
    </div>
  </section>
  </div>

  <div class="phase">
  <h2>Phase 5</h2>
  <section class="poster-tasks">

    <div class="task">
      <h2 onclick="toggleContent(event)">5-VIZ Visual representation of the buggy <span class="arrow">▶</span></h2>
      <div class="preview">
        The process of adding the API for submitting the buggies to the race server involved many changes to how the...
      </div>
      <div class="content">
        <p>
          To add the visual representation of the buggy into the form I used canvas elements and JavaScript to draw the buggy's design. The flag's pattern and colours were used to create the buggy's body, while the wheels were drawn below it. The image required making sure that the canvas properly showed the selected flag design, including the patterns picked by the user and making sure that the image updated in real-time as the user made changes.
        </p>
        <p>
          <!-- sentence(s) on anything interesting/incomplete you did -->
        </p>
      </div>
    </div>

    <div class="task">
      <h2 onclick="toggleContent(event)">5-ADMIN Add admin capabilities to superusers <span class="arrow">▶</span></h2>
      <div class="preview">
        To add an admin user to the buggy editor, I started by modifying the database init file to include...
      </div>
      <div class="content">
        <p>
          To add an admin user to the buggy editor, I started by modifying the database init file to include an `is_admin` column in the users table. This was done by updating the `init_db.py` file, which included a check to add the `is_admin` column if it did not already exist. At first, I had an error saying that the `is_admin` column did not exist, which was due to the existing table not being updated correctly. To fix this, I made sure the `init_db.py` code was robust enough to change the existing table in the pycache and add the new column. I also had issues with the SQLAlchemy ORM not recognising the `is_admin` column, which was fixed by checking that the column existed and ,making sure the database was correctly initialised. Finally, I added a default admin user with the `is_admin` attribute set to `true` for testing purposes. 
        </p>
        <p>
          After I added in the new code for the database changes I tried to create some new users, both with admin privileges and without. To do this I added a new entry into the signup form that took a boolean input from the user, a 1 for setting the user as an admin or a 0 for setting them as a standard user. After submitting the form to create an admin user I checked whether the ‘is_admin’ column in the database had a 1 to represent their admin status. It did, which was a good sign. I then tried to create a standard user, after creating a new standard user I checked the database but they also had a 1 in the ‘is_admin’ column. To see where this issue was originating I used print commands throughout the signup process printing the value of the ‘is_admin’ variable throughout. As soon as the form was submitted, no matter that the user inputted for the admin input, the ‘is_admin’ value was always 1. 
        </p>
        <p>
          To fix this, I changed the signup form logic to correctly store the state of the checkbox so when the form was submitted the correct value was stored in the database. Another issue was making sure that the edit and update routes correctly checked the user permissions when changing existing buggies. At first, the code didn't correctly restrict access, allowing standard users the ability to edit any buggy within the database. I fixed this by adding in more permission checks in both the `GET` and `POST` methods for the /edit route to make sure only the buggy owner or an admin user could edit. 
        </p>
        <p>
          Once all of these changes were made and after testing the signup form along with the edit-select page multiple times through the VS code testing feature the admin user was able to be added and has full CRUD permissions across all buggies within the database.         
        </p>
        <p> To finish off this task, because by project is running on gitLab for version control and I was working on a new branch to add the admin feature, I merged the admin_add branch to the main branch. </p>
      </div>
    </div>

    <div class="task">
      <h2 onclick="toggleContent(event)">5-USR MANAGEMENT Add user management features  <span class="arrow">▶</span></h2>
      <div class="preview">
        At the minute, if a user forgets their password they have no choice other than to make a new account...
      </div>
      <div class="content">
        <p>
          At the minute, if a user forgets their password they have no choice other than to make a new account. This isn’t user friendly as it means the user won’t be able to access any of their buggies anymore because they are associated with their account that they lost. To fix this I added in a password reset system. First I added in a new page to view and manage users stored in the database, for security reasons I wanted to limit access of this page just to admin users. To add this, I created a new template called `usersView.html`, which lists all users in the system. To make sure only admins can view and interact with the page, I updated the view function in the app.py file. The function checks if the current user is an admin before fetching and displaying all users. If a non-admin user attempts to access this page, they are redirected to their respective view with limited permissions. Also, to further make sure standard users can’t access the page, the ‘View Users’ button only shows if the current user is an admin by checking the stored value in the ‘is_admin’ column.
        </p>
        <p>
          To allow the administrator to reset user passwords I added in a new form block, using the same logic used in the signup form in the backend. I also added a delete button to allow unused users to be deleted from the database. 
        </p>

      </div>
    </div>
    
  </section>
  </div>

  <div class="phase">
    <h2>Phase 6</h2>
    <section class="poster-tasks">
  
      <div class="task">
        <h2 onclick="toggleContent(event)">6-SONAR Use sonarQube to run an analysis of the code  <span class="arrow">▶</span></h2>
        <div class="preview">
          SonarQube is used for analysing code quality. It does automatic checks of code to detect bugs, vulnerabilities, and code smells...
        </div>
        <div class="content">
          <p>SonarQube is used for analysing code quality. It does automatic checks of code to detect bugs, vulnerabilities, and code smells. To use this feature to ensure my code and web server are well written and don't have many vulnerabilities, I first installed a local instance of SonarQube. This was done by running the <code>sonar.sh</code> console command in the terminal. Then I ran these commands:</p>
          <pre>
          <code>
          sonar-scanner \
            -Dsonar.projectKey=buggy_editor \
            -Dsonar.sources=. \
            -Dsonar.host.url=http://localhost:9000 \
            -Dsonar.token=sqp_fcfd813187d80c8653a7ec52fdc90324dbf81eab
          </code>
          </pre>
          <p>These commands configured the project and connected it to work with the local web server. Once this correctly ran (this required installing brew and node to allow the analysis to be run on the JavaScript within the HTML files), the analysis was outputted to the web server.</p>
          <img src="{{ url_for('static', filename='analysis2.png') }}" alt="Analysis Screenshot" width="1079" height="664" style="border-radius: 10px;">


        </div>
      </div>
      
    </section>
    </div>

</div>

<div class="home-button">
  <a href="/index">Home</a>
</div>

{% endblock %}
